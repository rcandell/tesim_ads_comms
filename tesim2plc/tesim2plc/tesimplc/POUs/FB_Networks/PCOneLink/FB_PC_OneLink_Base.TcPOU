<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.0.36">
  <POU Name="FB_PC_OneLink_Base" Id="{fc681e10-3324-4803-8e35-b612a5046c5f}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_PC_OneLink_Base
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	ii: INT:=0;
	AFlowFilter: FB_recursiveFilter := (alpha := 0.3);
	DFlowFilter: FB_recursiveFilter := (alpha := 0.3);
	EFlowFilter: FB_recursiveFilter := (alpha := 0.3);
	ACFlowFilter: FB_recursiveFilter := (alpha := 0.3);
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//
// BEGIN PRODUCE THE DATA
//
// XMEAS values will come from the external TESIM program using ADS


//
// XMEAS SIGNAL PATHS
//
// CURRENT LOOPS for XMEAS Transmitters
XMEAS_IO_IOUT[XMEAS_IO_IDX.A_FLOW]		:= pv_float_to_dac(pv:=XMEAS[XMEAS_IDX.A_FLOW],		pv_max:=G_PARAMS.A_FLOW_MAX, pv_min:=G_PARAMS.A_FLOW_MIN, dac_max:=IOUT_WD_MAX, dac_min:=0);
XMEAS_IO_IOUT[XMEAS_IO_IDX.D_FLOW]		:= pv_float_to_dac(pv:=XMEAS[XMEAS_IDX.D_FLOW],		pv_max:=G_PARAMS.D_FLOW_MAX, pv_min:=G_PARAMS.D_FLOW_MIN, dac_max:=IOUT_WD_MAX, dac_min:=0);
XMEAS_IO_IOUT[XMEAS_IO_IDX.E_FLOW]		:= pv_float_to_dac(pv:=XMEAS[XMEAS_IDX.E_FLOW],		pv_max:=G_PARAMS.E_FLOW_MAX, pv_min:=G_PARAMS.E_FLOW_MIN, dac_max:=IOUT_WD_MAX, dac_min:=0);
XMEAS_IO_IOUT[XMEAS_IO_IDX.AC_FLOW]	:= pv_float_to_dac(pv:=XMEAS[XMEAS_IDX.AC_FLOW],	pv_max:=G_PARAMS.AC_FLOW_MAX, pv_min:=G_PARAMS.AC_FLOW_MIN, dac_max:=IOUT_WD_MAX, dac_min:=0);

// CURRENT LOOPS for XMEAS Receivers
G_IO.MBS_XMEAS[XMEAS_MBS_IDX.A_FLOW]	:=	LREAL_TO_REAL(adc_to_float_pv(G_IO.XMEAS_IO_IIN[XMEAS_MBS_IDX.A_FLOW]+G_ICAL.XMEAS_ILOOP_CAL[XMEAS_MBS_IDX.A_FLOW],		pv_max:=G_PARAMS.A_FLOW_MAX, 		pv_min:=G_PARAMS.A_FLOW_MIN, 	i_max:=G_PARAMS.IOUT_WD_MAX, i_min:=G_PARAMS.IOUT_WD_MIN));
G_IO.MBS_XMEAS[XMEAS_MBS_IDX.D_FLOW]	:=	LREAL_TO_REAL(adc_to_float_pv(G_IO.XMEAS_IO_IIN[XMEAS_MBS_IDX.D_FLOW]+G_ICAL.XMEAS_ILOOP_CAL[XMEAS_MBS_IDX.D_FLOW],		pv_max:=G_PARAMS.D_FLOW_MAX, 		pv_min:=G_PARAMS.D_FLOW_MIN, 	i_max:=G_PARAMS.IOUT_WD_MAX, i_min:=G_PARAMS.IOUT_WD_MIN));
G_IO.MBS_XMEAS[XMEAS_MBS_IDX.E_FLOW]	:=	LREAL_TO_REAL(adc_to_float_pv(G_IO.XMEAS_IO_IIN[XMEAS_MBS_IDX.E_FLOW]+G_ICAL.XMEAS_ILOOP_CAL[XMEAS_MBS_IDX.E_FLOW],		pv_max:=G_PARAMS.E_FLOW_MAX, 		pv_min:=G_PARAMS.E_FLOW_MIN, 	i_max:=G_PARAMS.IOUT_WD_MAX, i_min:=G_PARAMS.IOUT_WD_MIN));
G_IO.MBS_XMEAS[XMEAS_MBS_IDX.AC_FLOW]	:=	LREAL_TO_REAL(adc_to_float_pv(G_IO.XMEAS_IO_IIN[XMEAS_MBS_IDX.AC_FLOW]+G_ICAL.XMEAS_ILOOP_CAL[XMEAS_MBS_IDX.AC_FLOW],	pv_max:=G_PARAMS.AC_FLOW_MAX,   	pv_min:=G_PARAMS.AC_FLOW_MIN,   i_max:=G_PARAMS.IOUT_WD_MAX, i_min:=G_PARAMS.IOUT_WD_MIN));

// filter the noisy received values
AFlowFilter(xn:=G_IO.MBS_XMEAS[XMEAS_MBS_IDX.A_FLOW], yn=>G_IO.MBS_XMEAS[XMEAS_MBS_IDX.A_FLOW]);
DFlowFilter(xn:=G_IO.MBS_XMEAS[XMEAS_MBS_IDX.D_FLOW], yn=>G_IO.MBS_XMEAS[XMEAS_MBS_IDX.D_FLOW]);
EFlowFilter(xn:=G_IO.MBS_XMEAS[XMEAS_MBS_IDX.E_FLOW], yn=>G_IO.MBS_XMEAS[XMEAS_MBS_IDX.E_FLOW]);
ACFlowFilter(xn:=G_IO.MBS_XMEAS[XMEAS_MBS_IDX.AC_FLOW], yn=>G_IO.MBS_XMEAS[XMEAS_MBS_IDX.AC_FLOW]);

// capture the received state of XMEAS
FOR ii := 1 TO 41 DO
	XMEAS_RX[ii]:=XMEAS[ii];
END_FOR
XMEAS_RX[XMEAS_IDX.A_FLOW] := G_IO.MBS_XMEAS[XMEAS_MBS_IDX.A_FLOW];
XMEAS_RX[XMEAS_IDX.D_FLOW] := G_IO.MBS_XMEAS[XMEAS_MBS_IDX.D_FLOW];
XMEAS_RX[XMEAS_IDX.E_FLOW] := G_IO.MBS_XMEAS[XMEAS_MBS_IDX.E_FLOW];
XMEAS_RX[XMEAS_IDX.AC_FLOW] := G_IO.MBS_XMEAS[XMEAS_MBS_IDX.AC_FLOW];


//
// XMV SIGNAL PATHS
//
// CURRENT LOOPS for XMV Transmitters
XMV_IO_IOUT[XMV_IO_IDX.D_FLOW_VALVE]	:= pv_float_to_dac(pv:=XMV[XMV_IDX.D_FLOW_VALVE],	pv_max:=G_PARAMS.D_FLOW_VALVE_MAX, pv_min:=G_PARAMS.D_FLOW_VALVE_MIN, dac_max:=IOUT_WD_MAX, dac_min:=0);
XMV_IO_IOUT[XMV_IO_IDX.E_FLOW_VALVE]	:= pv_float_to_dac(pv:=XMV[XMV_IDX.E_FLOW_VALVE],	pv_max:=G_PARAMS.E_FLOW_VALVE_MAX, pv_min:=G_PARAMS.E_FLOW_VALVE_MIN, dac_max:=IOUT_WD_MAX, dac_min:=0);
XMV_IO_IOUT[XMV_IO_IDX.A_FLOW_VALVE]	:= pv_float_to_dac(pv:=XMV[XMV_IDX.A_FLOW_VALVE],	pv_max:=G_PARAMS.A_FLOW_VALVE_MAX, pv_min:=G_PARAMS.A_FLOW_VALVE_MIN, dac_max:=IOUT_WD_MAX, dac_min:=0);
XMV_IO_IOUT[XMV_IO_IDX.REACTOR_CWFV]	:= pv_float_to_dac(pv:=XMV[XMV_IDX.REACTOR_CWFV],	pv_max:=G_PARAMS.REACTOR_CWFV_MAX, pv_min:=G_PARAMS.REACTOR_CWFV_MIN, dac_max:=IOUT_WD_MAX, dac_min:=0);

// CURRENT LOOPS for XMV Receivers
G_IO.NET_XMV[XMV_IO_IDX.D_FLOW_VALVE]	:=	LREAL_TO_REAL(adc_to_float_pv(G_IO.XMV_IO_IIN[XMV_IO_IDX.D_FLOW_VALVE]+G_ICAL.XMV_ILOOP_CAL[XMV_IO_IDX.D_FLOW_VALVE],		pv_max:=G_PARAMS.D_FLOW_VALVE_MAX, 		pv_min:=G_PARAMS.D_FLOW_VALVE_MIN,	i_max:=G_PARAMS.IOUT_WD_MAX, i_min:=G_PARAMS.IOUT_WD_MIN));
G_IO.NET_XMV[XMV_IO_IDX.E_FLOW_VALVE]	:=	LREAL_TO_REAL(adc_to_float_pv(G_IO.XMV_IO_IIN[XMV_IO_IDX.E_FLOW_VALVE]+G_ICAL.XMV_ILOOP_CAL[XMV_IO_IDX.E_FLOW_VALVE],		pv_max:=G_PARAMS.E_FLOW_VALVE_MAX, 		pv_min:=G_PARAMS.E_FLOW_VALVE_MIN,	i_max:=G_PARAMS.IOUT_WD_MAX, i_min:=G_PARAMS.IOUT_WD_MIN));
G_IO.NET_XMV[XMV_IO_IDX.A_FLOW_VALVE]	:=	LREAL_TO_REAL(adc_to_float_pv(G_IO.XMV_IO_IIN[XMV_IO_IDX.A_FLOW_VALVE]+G_ICAL.XMV_ILOOP_CAL[XMV_IO_IDX.A_FLOW_VALVE],		pv_max:=G_PARAMS.A_FLOW_VALVE_MAX, 		pv_min:=G_PARAMS.A_FLOW_VALVE_MIN,	i_max:=G_PARAMS.IOUT_WD_MAX, i_min:=G_PARAMS.IOUT_WD_MIN));
G_IO.NET_XMV[XMV_IO_IDX.REACTOR_CWFV]	:=	LREAL_TO_REAL(adc_to_float_pv(G_IO.XMV_IO_IIN[XMV_IO_IDX.REACTOR_CWFV]+G_ICAL.XMV_ILOOP_CAL[XMV_IO_IDX.REACTOR_CWFV],		pv_max:=G_PARAMS.REACTOR_CWFV_MAX, 		pv_min:=G_PARAMS.REACTOR_CWFV_MIN,	i_max:=G_PARAMS.IOUT_WD_MAX, i_min:=G_PARAMS.IOUT_WD_MIN));

// capture the received state of XMV
FOR ii := 1 TO 12 DO
	XMV_RX[ii]:=XMV[ii];
END_FOR
XMV_RX[XMV_IDX.D_FLOW_VALVE] := G_IO.NET_XMV[XMV_IO_IDX.D_FLOW_VALVE];
XMV_RX[XMV_IDX.E_FLOW_VALVE] := G_IO.NET_XMV[XMV_IO_IDX.E_FLOW_VALVE];
XMV_RX[XMV_IDX.A_FLOW_VALVE] := G_IO.NET_XMV[XMV_IO_IDX.A_FLOW_VALVE];
XMV_RX[XMV_IDX.REACTOR_CWFV] := G_IO.NET_XMV[XMV_IO_IDX.REACTOR_CWFV];

]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>